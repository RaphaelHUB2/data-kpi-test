"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const anti_validator_1 = require("./anti.validator");
describe('AntiConstraint', () => {
    let antiConstraint;
    let validationArguments;
    beforeEach(() => {
        antiConstraint = new anti_validator_1.AntiConstraint();
    });
    describe('defaultMessage', () => {
        it('should return the correct error message', () => {
            validationArguments = {
                value: 'testValue',
                targetName: 'target',
                object: new Object('object'),
                constraints: ['isEmail'],
                property: 'email',
            };
            const result = antiConstraint.defaultMessage(validationArguments);
            expect(result).toBe('$property cannot be used with isEmail');
        });
    });
    describe('validate', () => {
        it('should return false because value and related value are truthy', () => {
            validationArguments = {
                value: 'testValue',
                targetName: 'target',
                object: { isEmail: 'foo' },
                constraints: ['isEmail'],
                property: 'email',
            };
            const result = antiConstraint.validate('testValue', validationArguments);
            expect(result).toBe(false);
        });
        it('should return true because value and related value are falsy', () => {
            validationArguments = {
                value: 'testValue',
                targetName: 'target',
                object: {},
                constraints: ['isEmail'],
                property: 'email',
            };
            const result = antiConstraint.validate(null, validationArguments);
            expect(result).toBe(true);
        });
        it('should return true because value is truthy but related value is falsy', () => {
            validationArguments = {
                value: 'testValue',
                targetName: 'target',
                object: {},
                constraints: ['isEmail'],
                property: 'email',
            };
            const result = antiConstraint.validate('testValue', validationArguments);
            expect(result).toBe(true);
        });
        it('should return true because value is truthy but related value is falsy', () => {
            validationArguments = {
                value: 'testValue',
                targetName: 'target',
                object: { isEmail: 'foo' },
                constraints: ['isEmail'],
                property: 'email',
            };
            const result = antiConstraint.validate(null, validationArguments);
            expect(result).toBe(true);
        });
    });
});
//# sourceMappingURL=anti.validator.spec.js.map